# 트리와 그래프
## 그래프란?
그래프는 vertex와 edge로 구성된 한정된 자료구조를 의미한다. vertex는 정점, edge는 정점과 정점을 연결하는 간선이다. <br>

### 그래프의 종류
1. 무방향 그래프
- 간선에 방향이 존재하지 않아 양방향으로 이동이 가능하다.
- (A,B), (B,A)는 동일한 간선이다
2. 방향 그래프
- 간선에 방향이 존재하는 그래프로 지정된 방향으로만 이동이 가능하다.
- A->B로 가는 간선은 <A,B>로 표시하며 <B,A>와는 다른 간선이다.

<hr>

3. 가중치 그래프
- 간선에 비용이나 가중치가 할당된 그래프이다.
4. 완전 그래프
- 한 정점에서 모든 다른 정점과 연결되어 최대의 간선수를 가지는 그래프
5. 단순 그래프
- 두 정점 사이의 연결선이 최대 한 개인 그래프
6. 부분 그래프
- 원래의 그래프에서 일부 정점이나 간선을 제거해 만든 그래프

## 그래프 구현 방법
그래프 구현 방법은 인접리스트 방법과 인접 행렬 방법 두가지로 나뉜다.
### 인접 리스트 방법
- 일반적인 그래프 표현 방법
- 모든 정점을 인접 리스트에 저장하고, 각각의 정점에 대해 인접한 정점들을 리스트로 표현한 것이다.
#### 구현 방식
- 각각의 연결리스트 헤더에 모든 정점을 하나씩 저장한다.<br>이 때 헤더 노드들은 하나의 배열로 붙어있다.
- 헤더에 연결되는 연결리스트에는 해당 헤더가 저장하고있는 노드에 인접한 노드들을 저장한다.
- 무방향 그래프인 경우 (a,b)는 a의 연결 리스트에 표시되고, b에도 표시해준다.

### 인접 행렬 방법
- n x n 불린 행렬로써 matrix[i][j]가 참이라면 i->j로의 간선이 존재한다는 의미이다.
- 노드가 n개인 그래프를 인접행렬로 표현하면 간선 수와 무관하게 n^2의 메모리 공간이 필요하다.
- 인접리스트는 어떤 노드에 대해 인접한 노드에 대해 바로 찾을 수 있지만 인접 행렬을 인접한 노드를 찾기위해서는 모든 노드를 전부 순회하여야하므로 효율성이 떨어진다.

<br><br>

## 트리란?
- 그래프의 일종으로, 여러 노드가 한 노드를 가리킬 수 없는 구조이다. 간단하게는 회로가 없고, 서로 다른 두 노드를 잇는 길이 하나뿐인 그래프를 트리라고 부른다.
- 트리에는 사이클이 존재할 수 없다.
-  최상위 노드를 루트 노드(root node)라고 한다. 또한 노드 A가 노드 B를 가리킬 때 A를 B의 부모 노드(parent node), B를 A의 자식 노드(child node)라고 한다. 
### 트리 종류
1. 이진 트리
- 각 노드가 최대 두 개의 자식을 갖는 트리
2. 이진 탐색 트리
- 이진트리의 속성을 만족하고 모든 노드에 대해 왼쪽 서브트리는 해당 노드보다 작은 값이, 오른쪽 서브트리는 해당 노드보다 큰 값을 가져야한다.
3. 완전 이진 트리
- 트리의 모든 높이에서 노드가 꽉 차 있는 이진 트리
- 마지막 레벨을 제외하고 모든 레벨이 완전히 채워져있는 이진트리

### 트리 순회
- 트리 순회란 트리의 모든 노드들을 방문하는 것을 순회라고 한다.
- 종류로는 전위 순회, 중위 순회, 후위 순회가 있다.

1. 전위 순회<br>
루트 노드의 먼저 방문하는 방법을 전위순회라고 한다.
- 루트노드를 방문한다.
- 왼편 서브트리를 전위 순회한다.
- 오른쪽 서브트리를 전위 순회 한다.

2. 중위 순회<br>
루트 노드를 중간에 방문하는 방법을 중위 순회라고 한다.
- 왼쪽 서브트리를 중위 순회한다.
- 루트 노드를 방문한다.
- 오른쪽 서브트리를 중위 순회한다.

3. 후위 순회<br>
루트 노드를 마지막에 방문하는 방법을 후위 순회라고 한다.
- 왼쪽 서브트리를 후위 순회한다.
- 오른쪽 서브트리를 후위 순회한다.
- 루트 노드를 방문한다.

# 깊이 우선 탐색과 너비 우선 탐색
## 깊이 우선 탐색 (DFS : Depth First Search)
- 루트 노드(혹은 다른 임의의 노드)에서 시작해서 다음 분기(branch)로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방법
- 한 방향으로 계속(깊게)탐색하고 더 이상 갈 길이 없으면 가장 가까운 분기점으로 돌아가 이곳에서 다른 방향으로 다시 탐색을 하는 방법
- 모든 노드를 방문하고자 할 때 사용하며, BFS보다 느리다.
- 재귀적으로 동작한다.

## 깊이 우선 탐색 구현
- 깊이 우선 탐색에서 가장 중요한 것은 스택과 방문 기록이다.

<방법>
- 현재 탐색 중인 노드 a를 스택에 넣고 노드와 연결된 노드 중 방문하지 않은 노드가 있는지 확인한다.
1. 방문하지 않은 노드가 있을 경우 
- 해당 노드(a의 자식 노드 중 방문하지 않은 노드)를 스택에 넣는다.- 방문하지 않은 노드가 있는지 확인하는 작업을 반복한다.
2. 방문하지 않은 노드가 없을 경우(자식 노드를 다 탐색하거나, 말단 노드이거나)
- 탐색 중이였던 a노드를 스택에서 제거한다.
- 스택 가장 위에 있는 노드를 꺼내 꺼낸 노드와 연결된 노드 중 방문하지 않은 노드가 있는지 확인하는 작업을 반복한다.

<br><br>

## 너비 우선 탐색(BFS : Breadth-Frist Search)
- 루트 노드(혹은 다른 임의의 노드)에서 시작해서 인접한 노드를 먼저 탐색하는 방법
- 시작하는 정점에서 가까운 정점부터 탐색을 시작해서 거리에 따라 단계별로 탐색을 한다고 볼 수 있다.
- 두 노드 사이의 최단 경로 혹은 임의의 경로를 찾고 싶을 때 이 방법을 선택한다.
- 재귀적으로 동작하지 않는다.

## 너비 우선 탐색 구현
- 너비 우선 탐색에서 가장 중요한 것은 큐와 방문 기록이다.

<방법>
1. 루트 노드를 큐에 집어 넣는다.
2. 큐에서 노드를 하나 꺼낸 후(첫번째 실행에서는 루트 노드) 꺼낸 노드에 연결되어 있는 노드 중 방문하지 않은 노드를 차례대로 큐에 삽입한다.
3. 다시 2번의 과정을 반복한다.